/*
 * Iris
 * (c) 2016+ Buenos Aires City Government
 * License: https://opensource.org/licenses/MIT
 *
 */

'use strict';

const Sparkles = require('sparkles');
const shortid = require('shortid');
const fs = require('graceful-fs');
const ora = require('ora');
const logger = require('winston');
const utils = require('../lib/utils/utils');

const consoleLog = utils.log;

shortid.characters('0123456789$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');

class Dispatcher {
    constructor() {
        this._name = 'dispatcher';
        this._config = {};
        this._tags = {};
        this._docks = {};
        this._threadPool = null;
        this._events = Sparkles('iris');
    }

    get tags() {
        return this._tags;
    }

    set config(options) {
        this._config = options;
        this._processConfig(this._config);
    }

    set threadPool(pool) {
        this._threadPool = pool;

        logger.silly('Set threadpool in dispatcher instance');
    }

    dispatch(data, callback) {
        logger.verbose('Received data from dock');
        data.meta.flow = this.tags[data.tag].flow.name;

        this._threadPool
            .send(data)
            .on('done', function (response) {
                logger.verbose('Received response from handler');
                this.respond(response);

                if (callback) {
                    callback(response.message);
                }
            }.bind(this));

        this._emitEvent('dispatch', {
            data: data
        });

        logger.verbose('Dispatched data to threadpool');
    }

    respond(response) {
        if (response) {
            this._docks[response.meta.dock].reply(response);

            this._emitEvent('respond', {
                data: response
            });

            logger.verbose('Sent response to original dock');
        }
    }

    _registerEventHandlers() {
        this._events.on('reload', function (event) {
            const newPool = this._loadJob(event.pool);

            logger.verbose('Reloaded compiled flows');

            this._threadPool.on('finished', function () {
                this._threadPool.killAll();
                this._threadPool = newPool;

                logger.verbose('Shut down old threadpool');
            }.bind(this));
        }.bind(this));
    }

    _emitEvent(event, data) {
        if (this._config.events) {
            this._events.emit(event, data);
            logger.silly('Emitted \'' + event + '\' event');
        };
    }

    _processConfig(config) {
        this._spinner = ora('Compiling flows').start();

        this._processFlows(config);
        this._generateJob(this.tags);
        this._loadJob.bind(this)(this._threadPool);
        this._registerEventHandlers();

        this._spinner.succeed();
        process.stdout.write('\n');
    }

    _processFlows(options) {
        options.flows.forEach(function (flow) {
            const container = {
                flow: flow,
                inputHooks: [],
                outputHooks: []
            };

            if (flow.inputHooks.length > 0) {
                flow.inputHooks.forEach(function (hook) {
                    container.inputHooks.push(hook.path);
                }, this);
            }

            if (flow.outputHooks.length > 0) {
                flow.outputHooks.forEach(function (hook) {
                    container.outputHooks.push(hook.path);
                }, this);
            }

            flow.docks.forEach(function (dock) {
                this._docks[dock.id] = dock;
            }, this);

            this.tags[flow.tag] = container;

            process.stdout.write('\r');
            logger.silly('Processed flow \'' + flow.tag + '\'');
        }, this);
    }

    _generateJob(tags) {
        const fileName = '.iris';

        const notice = "// This file is automatically generated. Any changes will be overwritten.\n\n";
        const defaultImports = "'use strict';\n\nconst parallel = require('fastparallel')();\n";
        const requireParts = [
            " = require('",
            "');\n"
        ];
        const moduleParts = [
            "\nmodule.exports = (data, done) => {\n    var response;\n\n    switch (data.tag) {\n",
            "    }\n};\n"
        ];
        const caseParts = [
            "        case '",
            "':\n            parallel({}, [",
            "], data, () => {});\n\n            response = ",
            "            break;\n"
        ];
        const ifParts = [
            ".handle(data);\n            if (response) {\n                parallel({}, [",
            "], response, () => {});\n\n" +
            "                let message = {message: response, tag: data.tag, meta: data.meta};\n" +
            "                done(message);\n            }\n            else done(false);\n"
        ];

        var job = notice + defaultImports;
        const cases = [];
        const dependencies = {};
        const paths = {};

        for (let property in tags) {
            if (tags.hasOwnProperty(property)) {
                let handlerPath = tags[property].flow.handler.path;
                let runnablesInput = [];
                let runnablesOutput = [];

                paths[handlerPath] = '_' + shortid.generate();
                dependencies['const ' + paths[handlerPath] + requireParts[0] + handlerPath + requireParts[1]] = true;

                tags[property].inputHooks.forEach(function (item) {
                    if (!paths[item]) {
                        paths[item] = '_' + shortid.generate();
                        dependencies['const ' + paths[item] + requireParts[0] + item + requireParts[1]] = true;
                    }

                    runnablesInput.push(paths[item] + '.run.bind(' + paths[item] + ')');
                }, this);

                tags[property].outputHooks.forEach(function (item) {
                    if (!paths[item]) {
                        paths[item] = '_' + shortid.generate();
                        dependencies['const ' + paths[item] + requireParts[0] + item + requireParts[1]] = true;
                    }

                    runnablesOutput.push(paths[item] + '.run.bind(' + paths[item] + ')');
                }, this);

                cases.push({
                    tag: property,
                    handler: paths[handlerPath],
                    runnablesInput: runnablesInput.join(', '),
                    runnablesOutput: runnablesOutput.join(', ')
                });
            }
        }

        job += Object.keys(dependencies).join('') + moduleParts[0];

        cases.forEach(function (item) {
            job += caseParts[0] + item.tag + caseParts[1] + item.runnablesInput + caseParts[2];
            job += item.handler + ifParts[0] + item.runnablesOutput + ifParts[1] + caseParts[3];
        }, this);

        job += moduleParts[1];

        fs.writeFileSync(fileName, job);

        logger.silly('Generated compiled flows file');
    }

    _loadJob(pool) {
        pool.run('.iris')
            .on('error', function (flow, error) {
                logger.error('[' + flow + ']', error);
            }.bind(this));

        logger.verbose('Loaded compiled flows in threadpool');

        for (let dockId in this._docks) {
            if (this._docks.hasOwnProperty(dockId)) {
                this._startDock(this._docks[dockId]);
            }
        }

        return pool;
    }

    _startDock(dock) {
        dock.stop();
        dock.listen(dock.config.port);
        logger.verbose('Started dock \'' + dock.name + '\' on port ' + dock.config.port);
    }
}

module.exports = new Dispatcher();